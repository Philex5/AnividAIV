import { Pool } from "pg";
import * as fs from "fs";
import * as path from "path";
import * as dotenv from "dotenv";

// Load environment variables
const envFile =
  process.env.NODE_ENV === "production"
    ? ".env.production"
    : ".env.development";
dotenv.config({ path: path.join(process.cwd(), envFile) });

const DATABASE_URL =
  "postgresql://postgres.finbdtigxoldlslyteki:qa282Udwe4x.Uzj@aws-1-us-east-2.pooler.supabase.com:6543/postgres";
if (!DATABASE_URL) {
  console.error("DATABASE_URL is not set in", envFile);
  process.exit(1);
}

// Output directory for CSV files
const OUTPUT_DIR = path.join(process.cwd(), "database-backups");

// Create output directory if it doesn't exist
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

/**
 * Columns that should be excluded from export (auto-generated by database)
 */
const EXCLUDED_COLUMNS = ["id", "created_at", "updated_at"];

/**
 * Check if a column should be excluded
 */
function shouldExcludeColumn(columnName: string): boolean {
  return EXCLUDED_COLUMNS.includes(columnName);
}

/**
 * Format a value for CSV export
 * - Date objects: Convert to ISO string without timezone (YYYY-MM-DD HH:mm:ss)
 * - Object types: Convert to JSON string
 * - Others: String conversion
 */
function formatValue(value: any): string {
  if (value === null || value === undefined) {
    return "";
  }

  // Handle Date objects - format as ISO without timezone
  if (value instanceof Date) {
    const year = value.getFullYear();
    const month = String(value.getMonth() + 1).padStart(2, "0");
    const day = String(value.getDate()).padStart(2, "0");
    const hours = String(value.getHours()).padStart(2, "0");
    const minutes = String(value.getMinutes()).padStart(2, "0");
    const seconds = String(value.getSeconds()).padStart(2, "0");
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  }

  // Handle objects (including nested objects/JSON)
  if (typeof value === "object") {
    return JSON.stringify(value);
  }

  return String(value);
}

/**
 * Escape a value for CSV format
 */
function escapeCsvValue(value: any): string {
  const strValue = formatValue(value);
  if (
    strValue.includes(",") ||
    strValue.includes('"') ||
    strValue.includes("\n")
  ) {
    return `"${strValue.replace(/"/g, '""')}"`;
  }
  return strValue;
}

/**
 * Convert row data to CSV line
 */
function rowToCsvLine(row: any, columns: string[]): string {
  return columns.map((col) => escapeCsvValue(row[col])).join(",");
}

/**
 * Convert array of rows to CSV content
 */
function rowsToCsv(rows: any[], columns: string[]): string {
  const header = columns.map(escapeCsvValue).join(",");
  const data = rows.map((row) => rowToCsvLine(row, columns));
  return [header, ...data].join("\n");
}

/**
 * Export all tables from database to CSV files
 */
async function exportDatabaseToCsv() {
  const pool = new Pool({ connectionString: DATABASE_URL });

  try {
    console.log("Connecting to database...");
    const client = await pool.connect();
    console.log("Connected successfully!\n");

    try {
      // Get all table names in the public schema
      const tablesQuery = `
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public'
        AND table_type = 'BASE TABLE'
        ORDER BY table_name;
      `;
      const tablesResult = await client.query(tablesQuery);
      const tables = tablesResult.rows.map((row) => row.table_name);

      console.log(`Found ${tables.length} tables to export:\n`);

      // Export each table
      for (const table of tables) {
        console.log(`Exporting table: ${table}`);

        // Get column names (excluding auto-generated columns)
        const columnsQuery = `
          SELECT column_name
          FROM information_schema.columns
          WHERE table_schema = 'public'
          AND table_name = $1
          ORDER BY ordinal_position;
        `;
        const columnsResult = await client.query(columnsQuery, [table]);
        const columns = columnsResult.rows
          .map((row) => row.column_name)
          .filter((col) => !shouldExcludeColumn(col));

        // Get all data from the table
        const dataQuery = `SELECT * FROM "${table}";`;
        const dataResult = await client.query(dataQuery);
        const rows = dataResult.rows;

        // Convert to CSV
        const csvContent = rowsToCsv(rows, columns);

        // Write to file
        const filename = `${table}.csv`;
        const filepath = path.join(OUTPUT_DIR, filename);
        fs.writeFileSync(filepath, csvContent);

        console.log(`  ✓ Exported ${rows.length} rows to ${filename}`);
      }

      console.log(`\n✓ All tables exported to: ${OUTPUT_DIR}`);
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error exporting database:", error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

/**
 * Export specific tables from database to CSV files
 */
async function exportTablesToCsv(tableNames: string[]) {
  const pool = new Pool({ connectionString: DATABASE_URL });

  try {
    console.log("Connecting to database...");
    const client = await pool.connect();
    console.log("Connected successfully!\n");

    try {
      for (const table of tableNames) {
        console.log(`Exporting table: ${table}`);

        // Get column names (excluding auto-generated columns)
        const columnsQuery = `
          SELECT column_name
          FROM information_schema.columns
          WHERE table_schema = 'public'
          AND table_name = $1
          ORDER BY ordinal_position;
        `;
        const columnsResult = await client.query(columnsQuery, [table]);
        const columns = columnsResult.rows
          .map((row) => row.column_name)
          .filter((col) => !shouldExcludeColumn(col));

        // Get all data from the table
        const dataQuery = `SELECT * FROM "${table}";`;
        const dataResult = await client.query(dataQuery);
        const rows = dataResult.rows;

        // Convert to CSV
        const csvContent = rowsToCsv(rows, columns);

        // Write to file
        const filename = `${table}.csv`;
        const filepath = path.join(OUTPUT_DIR, filename);
        fs.writeFileSync(filepath, csvContent);

        console.log(`  ✓ Exported ${rows.length} rows to ${filename}`);
      }

      console.log(`\n✓ Tables exported to: ${OUTPUT_DIR}`);
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error exporting database:", error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
const mode = args[0] || "all";

if (mode === "all") {
  exportDatabaseToCsv();
} else if (mode === "tables" && args.length > 1) {
  const tableNames = args.slice(1);
  exportTablesToCsv(tableNames);
} else {
  console.log("Usage:");
  console.log(
    "  tsx scripts/export-database-to-csv.ts all          # Export all tables",
  );
  console.log(
    "  tsx scripts/export-database-to-csv.ts tables <name> [<name>...]  # Export specific tables",
  );
  console.log("");
  console.log("Examples:");
  console.log("  pnpm db:export");
  console.log("  pnpm db:export:tables users orders");
  process.exit(1);
}
